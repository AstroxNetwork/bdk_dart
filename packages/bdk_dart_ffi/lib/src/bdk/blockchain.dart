// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'types.dart';
part 'blockchain.freezed.dart';

@freezed
sealed class BlockchainConfig with _$BlockchainConfig {
  const BlockchainConfig._();

  /// Electrum client
  const factory BlockchainConfig.electrum({
    required ElectrumConfig config,
  }) = BlockchainConfig_Electrum;

  /// Esplora client
  const factory BlockchainConfig.esplora({
    required EsploraConfig config,
  }) = BlockchainConfig_Esplora;

  /// Bitcoin Core RPC client
  const factory BlockchainConfig.rpc({
    required RpcConfig config,
  }) = BlockchainConfig_Rpc;
}

/// Configuration for an ElectrumBlockchain
class ElectrumConfig {
  ///URL of the Electrum server (such as ElectrumX, Esplora, BWT) may start with ssl:// or tcp:// and include a port
  ///eg. ssl://electrum.blockstream.info:60002
  final String url;

  ///URL of the socks5 proxy server or a Tor service
  final String? socks5;

  ///Request retry count
  final int retry;

  ///Request timeout (seconds)
  final int? timeout;

  ///Stop searching addresses for transactions after finding an unused gap of this length
  final BigInt stopGap;

  /// Validate the domain when using SSL
  final bool validateDomain;

  const ElectrumConfig({
    required this.url,
    this.socks5,
    required this.retry,
    this.timeout,
    required this.stopGap,
    required this.validateDomain,
  });

  @override
  int get hashCode =>
      url.hashCode ^
      socks5.hashCode ^
      retry.hashCode ^
      timeout.hashCode ^
      stopGap.hashCode ^
      validateDomain.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ElectrumConfig &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          socks5 == other.socks5 &&
          retry == other.retry &&
          timeout == other.timeout &&
          stopGap == other.stopGap &&
          validateDomain == other.validateDomain;
}

///Configuration for an EsploraBlockchain
class EsploraConfig {
  ///Base URL of the esplora service
  ///eg. https://blockstream.info/api/
  final String baseUrl;

  ///  Optional URL of the proxy to use to make requests to the Esplora server
  /// The string should be formatted as: <protocol>://<user>:<password>@host:<port>.
  /// Note that the format of this value and the supported protocols change slightly between the sync version of esplora (using ureq) and the async version (using reqwest).
  ///  For more details check with the documentation of the two crates. Both of them are compiled with the socks feature enabled.
  /// The proxy is ignored when targeting wasm32.
  final String? proxy;

  ///Number of parallel requests sent to the esplora service (default: 4)
  final int? concurrency;

  ///Stop searching addresses for transactions after finding an unused gap of this length.
  final BigInt stopGap;

  ///Socket timeout.
  final BigInt? timeout;

  const EsploraConfig({
    required this.baseUrl,
    this.proxy,
    this.concurrency,
    required this.stopGap,
    this.timeout,
  });

  @override
  int get hashCode =>
      baseUrl.hashCode ^
      proxy.hashCode ^
      concurrency.hashCode ^
      stopGap.hashCode ^
      timeout.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EsploraConfig &&
          runtimeType == other.runtimeType &&
          baseUrl == other.baseUrl &&
          proxy == other.proxy &&
          concurrency == other.concurrency &&
          stopGap == other.stopGap &&
          timeout == other.timeout;
}

class RpcConfig {
  /// The bitcoin node url
  final String url;

  /// The bitcoin node authentication mechanism
  final String? authCookie;
  final UserPass? authUserPass;

  /// The network we are using (it will be checked the bitcoin node network matches this)
  final Network network;

  /// The wallet name in the bitcoin node
  final String walletName;

  /// Sync parameters
  final RpcSyncParams? syncParams;

  const RpcConfig({
    required this.url,
    this.authCookie,
    this.authUserPass,
    required this.network,
    required this.walletName,
    this.syncParams,
  });

  @override
  int get hashCode =>
      url.hashCode ^
      authCookie.hashCode ^
      authUserPass.hashCode ^
      network.hashCode ^
      walletName.hashCode ^
      syncParams.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RpcConfig &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          authCookie == other.authCookie &&
          authUserPass == other.authUserPass &&
          network == other.network &&
          walletName == other.walletName &&
          syncParams == other.syncParams;
}

/// Sync parameters for Bitcoin Core RPC.
///
/// In general, BDK tries to sync `scriptPubKey`s cached in `Database` with
/// `scriptPubKey`s imported in the Bitcoin Core Wallet. These parameters are used for determining
/// how the `importdescriptors` RPC calls are to be made.
///
class RpcSyncParams {
  /// The minimum number of scripts to scan for on initial sync.
  final BigInt startScriptCount;

  /// Time in unix seconds in which initial sync will start scanning from (0 to start from genesis).
  final BigInt startTime;

  /// Forces every sync to use `start_time` as import timestamp.
  final bool forceStartTime;

  /// RPC poll rate (in seconds) to get state updates.
  final BigInt pollRateSec;

  const RpcSyncParams({
    required this.startScriptCount,
    required this.startTime,
    required this.forceStartTime,
    required this.pollRateSec,
  });

  @override
  int get hashCode =>
      startScriptCount.hashCode ^
      startTime.hashCode ^
      forceStartTime.hashCode ^
      pollRateSec.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RpcSyncParams &&
          runtimeType == other.runtimeType &&
          startScriptCount == other.startScriptCount &&
          startTime == other.startTime &&
          forceStartTime == other.forceStartTime &&
          pollRateSec == other.pollRateSec;
}

/// RpcBlockchain configuration options
///
class UserPass {
  /// Username
  final String username;

  /// Password
  final String password;

  const UserPass({
    required this.username,
    required this.password,
  });

  @override
  int get hashCode => username.hashCode ^ password.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserPass &&
          runtimeType == other.runtimeType &&
          username == other.username &&
          password == other.password;
}
