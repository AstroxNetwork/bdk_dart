// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.5.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::*;
use crate::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.5.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 1341622589;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__api_address_from_script_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_address_from_script",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_script = <crate::bdk::types::Script>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::Api::address_from_script(api_script, api_network)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_address_network_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_address_network",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_address = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::address_network(api_address)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_address_to_script_pubkey_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_address_to_script_pubkey",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_address = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::address_to_script_pubkey(api_address)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_as_public_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_as_public",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_secret = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::as_public(api_secret)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_as_secret_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_as_secret_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_secret = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::as_secret_bytes(api_secret)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_as_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_as_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_descriptor = <RustOpaqueMoi<BdkDescriptor>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::Api::as_string(api_descriptor))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_as_string_private_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_as_string_private",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_descriptor = <RustOpaqueMoi<BdkDescriptor>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::Api::as_string_private(api_descriptor))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_bip322_sign_segwit_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_bip322_sign_segwit",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_secret = <Vec<u8>>::sse_decode(&mut deserializer);
            let api_message = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::bip322_sign_segwit(
                        api_secret,
                        api_message,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_bip322_sign_taproot_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_bip322_sign_taproot",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_secret = <Vec<u8>>::sse_decode(&mut deserializer);
            let api_message = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::bip322_sign_taproot(
                        api_secret,
                        api_message,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_broadcast_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_broadcast",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            let api_blockchain = <RustOpaqueMoi<BlockchainInstance>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::broadcast(api_tx, api_blockchain)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_bump_fee_tx_builder_finish_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_bump_fee_tx_builder_finish",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_txid = <String>::sse_decode(&mut deserializer);
            let api_fee_rate = <f32>::sse_decode(&mut deserializer);
            let api_allow_shrinking = <Option<String>>::sse_decode(&mut deserializer);
            let api_wallet = <RustOpaqueMoi<WalletInstance>>::sse_decode(&mut deserializer);
            let api_enable_rbf = <bool>::sse_decode(&mut deserializer);
            let api_keep_change = <bool>::sse_decode(&mut deserializer);
            let api_n_sequence = <Option<u32>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::bump_fee_tx_builder_finish(
                            api_txid,
                            api_fee_rate,
                            api_allow_shrinking,
                            api_wallet,
                            api_enable_rbf,
                            api_keep_change,
                            api_n_sequence,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_cache_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_cache_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet = <RustOpaqueMoi<WalletInstance>>::sse_decode(&mut deserializer);
            let api_cache_size = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::cache_address(api_wallet, api_cache_size)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_combine_psbt_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_combine_psbt",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            let api_other = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::combine_psbt(api_psbt_str, api_other)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_create_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_address = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::create_address(api_address)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_create_blockchain_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_blockchain",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_config =
                <crate::bdk::blockchain::BlockchainConfig>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::create_blockchain(api_config)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_create_derivation_path_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_derivation_path",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::create_derivation_path(api_path)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_create_derived_descriptor_secret_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_derived_descriptor_secret",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            let api_mnemonic = <String>::sse_decode(&mut deserializer);
            let api_path = <String>::sse_decode(&mut deserializer);
            let api_password = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::create_derived_descriptor_secret(
                            api_network,
                            api_mnemonic,
                            api_path,
                            api_password,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_create_descriptor_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_descriptor",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_descriptor = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::Api::create_descriptor(api_descriptor, api_network)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_create_descriptor_public_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_descriptor_public",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_xpub = <Option<String>>::sse_decode(&mut deserializer);
            let api_path = <String>::sse_decode(&mut deserializer);
            let api_derive = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::create_descriptor_public(
                            api_xpub, api_path, api_derive,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_create_descriptor_secret_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_descriptor_secret",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            let api_mnemonic = <String>::sse_decode(&mut deserializer);
            let api_password = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::create_descriptor_secret(
                            api_network,
                            api_mnemonic,
                            api_password,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_create_script_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_script",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_raw_output_script = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::create_script(api_raw_output_script)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_create_transaction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_transaction",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::create_transaction(api_tx)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_create_wallet_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_create_wallet",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_descriptor = <RustOpaqueMoi<BdkDescriptor>>::sse_decode(&mut deserializer);
            let api_change_descriptor =
                <Option<RustOpaqueMoi<BdkDescriptor>>>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            let api_database_config =
                <crate::bdk::wallet::DatabaseConfig>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::create_wallet(
                            api_descriptor,
                            api_change_descriptor,
                            api_network,
                            api_database_config,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_derive_address_at_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_derive_address_at",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_descriptor = <RustOpaqueMoi<BdkDescriptor>>::sse_decode(&mut deserializer);
            let api_index = <u32>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::derive_address_at(
                            api_descriptor,
                            api_index,
                            api_network,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_derive_descriptor_secret_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_derive_descriptor_secret",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_secret = <String>::sse_decode(&mut deserializer);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::Api::derive_descriptor_secret(api_secret, api_path),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_descriptor_public_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_descriptor_public_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_public_key = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::Api::descriptor_public_from_string(api_public_key)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_descriptor_secret_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_descriptor_secret_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_secret = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::descriptor_secret_from_string(api_secret)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_estimate_fee_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_estimate_fee",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_target = <u64>::sse_decode(&mut deserializer);
            let api_blockchain = <RustOpaqueMoi<BlockchainInstance>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::estimate_fee(api_target, api_blockchain)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_extend_descriptor_secret_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_extend_descriptor_secret",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_secret = <String>::sse_decode(&mut deserializer);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::Api::extend_descriptor_secret(api_secret, api_path),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_extract_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_extract_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::extract_tx(api_psbt_str)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_generate_seed_from_entropy_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_generate_seed_from_entropy",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_entropy = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::generate_seed_from_entropy(api_entropy)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_generate_seed_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_generate_seed_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mnemonic = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::generate_seed_from_string(api_mnemonic)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_generate_seed_from_word_count_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_generate_seed_from_word_count",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_word_count = <crate::bdk::types::WordCount>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::Api::generate_seed_from_word_count(api_word_count),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_get_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet = <RustOpaqueMoi<WalletInstance>>::sse_decode(&mut deserializer);
            let api_address_index =
                <crate::bdk::types::AddressIndex>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::Api::get_address(api_wallet, api_address_index)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_get_address_type_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_address_type",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_address = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::get_address_type(api_address)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_get_balance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_balance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet = <RustOpaqueMoi<WalletInstance>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::get_balance(api_wallet)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_get_blockchain_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_blockchain_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_blockchain_height = <u32>::sse_decode(&mut deserializer);
            let api_blockchain = <RustOpaqueMoi<BlockchainInstance>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::get_blockchain_hash(
                            api_blockchain_height,
                            api_blockchain,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_get_height_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_height",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_blockchain = <RustOpaqueMoi<BlockchainInstance>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::get_height(api_blockchain)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_get_inputs_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_inputs",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::get_inputs(api_psbt_str)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_get_internal_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_internal_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet = <RustOpaqueMoi<WalletInstance>>::sse_decode(&mut deserializer);
            let api_address_index =
                <crate::bdk::types::AddressIndex>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::Api::get_internal_address(api_wallet, api_address_index)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_get_pub_from_secret_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_pub_from_secret_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_bytes = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::Api::get_pub_from_secret_bytes(api_bytes))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_get_transactions_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_transactions",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet = <RustOpaqueMoi<WalletInstance>>::sse_decode(&mut deserializer);
            let api_include_raw = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::Api::get_transactions(api_wallet, api_include_raw)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_get_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_get_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            let api_blockchain = <RustOpaqueMoi<BlockchainInstance>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::get_tx(api_tx, api_blockchain)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_import_single_wif_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_import_single_wif",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wif = <String>::sse_decode(&mut deserializer);
            let api_address_type = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::import_single_wif(
                        api_wif,
                        api_address_type,
                        api_network,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_input_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_input",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::input(api_tx))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_is_coin_base_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_is_coin_base",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::is_coin_base(api_tx))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_is_explicitly_rbf_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_is_explicitly_rbf",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::Api::is_explicitly_rbf(api_tx))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_is_lock_time_enabled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_is_lock_time_enabled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::Api::is_lock_time_enabled(api_tx))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_json_serialize_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_json_serialize",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::json_serialize(api_psbt_str)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_list_unspent_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_list_unspent",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet = <RustOpaqueMoi<WalletInstance>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::list_unspent(api_wallet)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_list_unspent_outputs_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_list_unspent_outputs",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet = <RustOpaqueMoi<WalletInstance>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::list_unspent_outputs(api_wallet)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_lock_time_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_lock_time",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::lock_time(api_tx))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_master_finterprint_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_master_finterprint",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_xpub = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::master_finterprint(api_xpub)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_new_bip44_descriptor_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_new_bip44_descriptor",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key_chain_kind =
                <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            let api_secret_key = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::new_bip44_descriptor(
                        api_key_chain_kind,
                        api_secret_key,
                        api_network,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_new_bip44_public_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_new_bip44_public",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key_chain_kind =
                <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            let api_public_key = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            let api_fingerprint = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::new_bip44_public(
                        api_key_chain_kind,
                        api_public_key,
                        api_network,
                        api_fingerprint,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_new_bip44_tr_descriptor_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_new_bip44_tr_descriptor",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key_chain_kind =
                <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            let api_secret_key = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::new_bip44_tr_descriptor(
                        api_key_chain_kind,
                        api_secret_key,
                        api_network,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_new_bip44_tr_public_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_new_bip44_tr_public",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key_chain_kind =
                <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            let api_public_key = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            let api_fingerprint = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::new_bip44_tr_public(
                        api_key_chain_kind,
                        api_public_key,
                        api_network,
                        api_fingerprint,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_new_bip49_descriptor_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_new_bip49_descriptor",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key_chain_kind =
                <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            let api_secret_key = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::new_bip49_descriptor(
                        api_key_chain_kind,
                        api_secret_key,
                        api_network,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_new_bip49_public_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_new_bip49_public",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key_chain_kind =
                <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            let api_public_key = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            let api_fingerprint = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::new_bip49_public(
                        api_key_chain_kind,
                        api_public_key,
                        api_network,
                        api_fingerprint,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_new_bip84_descriptor_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_new_bip84_descriptor",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key_chain_kind =
                <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            let api_secret_key = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::new_bip84_descriptor(
                        api_key_chain_kind,
                        api_secret_key,
                        api_network,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_new_bip84_public_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_new_bip84_public",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key_chain_kind =
                <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            let api_public_key = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            let api_fingerprint = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::new_bip84_public(
                        api_key_chain_kind,
                        api_public_key,
                        api_network,
                        api_fingerprint,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_new_bip86_descriptor_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_new_bip86_descriptor",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key_chain_kind =
                <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            let api_secret_key = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::new_bip86_descriptor(
                        api_key_chain_kind,
                        api_secret_key,
                        api_network,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_new_bip86_public_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_new_bip86_public",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_key_chain_kind =
                <crate::bdk::types::KeychainKind>::sse_decode(&mut deserializer);
            let api_public_key = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            let api_fingerprint = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::new_bip86_public(
                        api_key_chain_kind,
                        api_public_key,
                        api_network,
                        api_fingerprint,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_output_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_output",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::output(api_tx))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_payload_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_payload",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_address = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::payload(api_address)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_psbt_fee_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_psbt_fee_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::Api::psbt_fee_amount(api_psbt_str))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_psbt_fee_rate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_psbt_fee_rate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::Api::psbt_fee_rate(api_psbt_str))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_psbt_txid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_psbt_txid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::psbt_txid(api_psbt_str)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_serialize_psbt_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_serialize_psbt",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::serialize_psbt(api_psbt_str)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_serialize_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_serialize_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::serialize_tx(api_tx))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_sign_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_sign",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet = <RustOpaqueMoi<WalletInstance>>::sse_decode(&mut deserializer);
            let api_psbt_str = <String>::sse_decode(&mut deserializer);
            let api_sign_options =
                <Option<crate::bdk::wallet::SignOptions>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::sign(
                        api_wallet,
                        api_psbt_str,
                        api_sign_options,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_size",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::size(api_tx))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_to_public_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_to_public_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_xpub = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::to_public_string(api_xpub)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_tx_builder_finish_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_tx_builder_finish",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet = <RustOpaqueMoi<WalletInstance>>::sse_decode(&mut deserializer);
            let api_recipients =
                <Vec<crate::bdk::types::ScriptAmount>>::sse_decode(&mut deserializer);
            let api_txs = <Vec<crate::bdk::types::TxBytes>>::sse_decode(&mut deserializer);
            let api_unspendable = <Vec<crate::bdk::types::OutPoint>>::sse_decode(&mut deserializer);
            let api_foreign_utxos =
                <Vec<crate::bdk::types::ForeignUtxo>>::sse_decode(&mut deserializer);
            let api_change_policy =
                <crate::bdk::types::ChangeSpendPolicy>::sse_decode(&mut deserializer);
            let api_manually_selected_only = <bool>::sse_decode(&mut deserializer);
            let api_fee_rate = <Option<f32>>::sse_decode(&mut deserializer);
            let api_fee_absolute = <Option<u64>>::sse_decode(&mut deserializer);
            let api_drain_wallet = <bool>::sse_decode(&mut deserializer);
            let api_drain_to = <Option<crate::bdk::types::Script>>::sse_decode(&mut deserializer);
            let api_rbf = <Option<crate::bdk::types::RbfValue>>::sse_decode(&mut deserializer);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            let api_shuffle_utxo = <Option<bool>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::tx_builder_finish(
                            api_wallet,
                            api_recipients,
                            api_txs,
                            api_unspendable,
                            api_foreign_utxos,
                            api_change_policy,
                            api_manually_selected_only,
                            api_fee_rate,
                            api_fee_absolute,
                            api_drain_wallet,
                            api_drain_to,
                            api_rbf,
                            api_data,
                            api_shuffle_utxo,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_tx_cal_fee_finish_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_tx_cal_fee_finish",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet = <RustOpaqueMoi<WalletInstance>>::sse_decode(&mut deserializer);
            let api_recipients =
                <Vec<crate::bdk::types::ScriptAmount>>::sse_decode(&mut deserializer);
            let api_txs = <Vec<crate::bdk::types::TxBytes>>::sse_decode(&mut deserializer);
            let api_unspendable = <Vec<crate::bdk::types::OutPoint>>::sse_decode(&mut deserializer);
            let api_foreign_utxos =
                <Vec<crate::bdk::types::ForeignUtxo>>::sse_decode(&mut deserializer);
            let api_change_policy =
                <crate::bdk::types::ChangeSpendPolicy>::sse_decode(&mut deserializer);
            let api_manually_selected_only = <bool>::sse_decode(&mut deserializer);
            let api_fee_rate = <Option<f32>>::sse_decode(&mut deserializer);
            let api_fee_absolute = <Option<u64>>::sse_decode(&mut deserializer);
            let api_drain_wallet = <bool>::sse_decode(&mut deserializer);
            let api_drain_to = <Option<crate::bdk::types::Script>>::sse_decode(&mut deserializer);
            let api_rbf = <Option<crate::bdk::types::RbfValue>>::sse_decode(&mut deserializer);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            let api_shuffle_utxo = <Option<bool>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::tx_cal_fee_finish(
                            api_wallet,
                            api_recipients,
                            api_txs,
                            api_unspendable,
                            api_foreign_utxos,
                            api_change_policy,
                            api_manually_selected_only,
                            api_fee_rate,
                            api_fee_absolute,
                            api_drain_wallet,
                            api_drain_to,
                            api_rbf,
                            api_data,
                            api_shuffle_utxo,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_tx_txid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_tx_txid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::Api::tx_txid(api_tx)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__api_version_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_version",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::version(api_tx))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_vsize_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_vsize",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::vsize(api_tx))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_wallet_network_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_wallet_network",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wallet = <RustOpaqueMoi<WalletInstance>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::Api::wallet_network(api_wallet))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__api_weight_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "api_weight",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tx = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::Api::weight(api_tx))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__hex_bytes_to_wif_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "hex_bytes_to_wif",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_hex = <String>::sse_decode(&mut deserializer);
            let api_network = <crate::bdk::types::Network>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::hex_bytes_to_wif(api_hex, api_network)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__secp256k1_from_seed_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "secp256k1_from_seed",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_req = <crate::types::Secp256k1FromSeedReq>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::secp256k1_from_seed(api_req))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__secp256k1_get_shared_secret_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "secp256k1_get_shared_secret",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_req = <crate::types::Secp256k1ShareSecretReq>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::secp256k1_get_shared_secret(api_req))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__secp256k1_recover_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "secp256k1_recover",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_req = <crate::types::Secp256k1RecoverReq>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::secp256k1_recover(api_req))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__secp256k1_sign_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "secp256k1_sign",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_req = <crate::types::Secp256k1SignWithSeedReq>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::secp256k1_sign(api_req))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__secp256k1_sign_recoverable_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "secp256k1_sign_recoverable",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_req = <crate::types::Secp256k1SignWithSeedReq>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::secp256k1_sign_recoverable(api_req))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__secp256k1_sign_with_rng_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "secp256k1_sign_with_rng",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_req = <crate::types::Secp256k1SignWithRngReq>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::secp256k1_sign_with_rng(api_req))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__secp256k1_verify_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "secp256k1_verify",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_req = <crate::types::Secp256k1VerifyReq>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::secp256k1_verify(api_req))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(BdkDescriptor);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(BlockchainInstance);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(WalletInstance);

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for RustOpaqueMoi<BdkDescriptor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<BlockchainInstance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<WalletInstance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::bdk::types::AddressIndex {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::bdk::types::AddressIndex::NewIndex;
            }
            1 => {
                return crate::bdk::types::AddressIndex::LastUnused;
            }
            2 => {
                let mut var_index = <u32>::sse_decode(deserializer);
                return crate::bdk::types::AddressIndex::Peek { index: var_index };
            }
            3 => {
                let mut var_index = <u32>::sse_decode(deserializer);
                return crate::bdk::types::AddressIndex::Reset { index: var_index };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::bdk::types::AddressInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_index = <u32>::sse_decode(deserializer);
        let mut var_address = <String>::sse_decode(deserializer);
        return crate::bdk::types::AddressInfo {
            index: var_index,
            address: var_address,
        };
    }
}

impl SseDecode for crate::api::Api {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::api::Api {};
    }
}

impl SseDecode for crate::bdk::types::Balance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_immature = <u64>::sse_decode(deserializer);
        let mut var_trustedPending = <u64>::sse_decode(deserializer);
        let mut var_untrustedPending = <u64>::sse_decode(deserializer);
        let mut var_confirmed = <u64>::sse_decode(deserializer);
        let mut var_spendable = <u64>::sse_decode(deserializer);
        let mut var_total = <u64>::sse_decode(deserializer);
        return crate::bdk::types::Balance {
            immature: var_immature,
            trusted_pending: var_trustedPending,
            untrusted_pending: var_untrustedPending,
            confirmed: var_confirmed,
            spendable: var_spendable,
            total: var_total,
        };
    }
}

impl SseDecode for crate::bdk::types::BdkTxBuilderResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <crate::bdk::types::TransactionDetails>::sse_decode(deserializer);
        return crate::bdk::types::BdkTxBuilderResult(var_field0, var_field1);
    }
}

impl SseDecode for crate::bdk::types::BlockTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_height = <u32>::sse_decode(deserializer);
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        return crate::bdk::types::BlockTime {
            height: var_height,
            timestamp: var_timestamp,
        };
    }
}

impl SseDecode for crate::bdk::blockchain::BlockchainConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_config =
                    <crate::bdk::blockchain::ElectrumConfig>::sse_decode(deserializer);
                return crate::bdk::blockchain::BlockchainConfig::Electrum { config: var_config };
            }
            1 => {
                let mut var_config =
                    <crate::bdk::blockchain::EsploraConfig>::sse_decode(deserializer);
                return crate::bdk::blockchain::BlockchainConfig::Esplora { config: var_config };
            }
            2 => {
                let mut var_config = <crate::bdk::blockchain::RpcConfig>::sse_decode(deserializer);
                return crate::bdk::blockchain::BlockchainConfig::Rpc { config: var_config };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::bdk::types::ChangeSpendPolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::bdk::types::ChangeSpendPolicy::ChangeAllowed,
            1 => crate::bdk::types::ChangeSpendPolicy::OnlyChange,
            2 => crate::bdk::types::ChangeSpendPolicy::ChangeForbidden,
            _ => unreachable!("Invalid variant for ChangeSpendPolicy: {}", inner),
        };
    }
}

impl SseDecode for crate::bdk::wallet::DatabaseConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::bdk::wallet::DatabaseConfig::Memory;
            }
            1 => {
                let mut var_config =
                    <crate::bdk::wallet::SqliteDbConfiguration>::sse_decode(deserializer);
                return crate::bdk::wallet::DatabaseConfig::Sqlite { config: var_config };
            }
            2 => {
                let mut var_config =
                    <crate::bdk::wallet::SledDbConfiguration>::sse_decode(deserializer);
                return crate::bdk::wallet::DatabaseConfig::Sled { config: var_config };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::bdk::blockchain::ElectrumConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_socks5 = <Option<String>>::sse_decode(deserializer);
        let mut var_retry = <u8>::sse_decode(deserializer);
        let mut var_timeout = <Option<u8>>::sse_decode(deserializer);
        let mut var_stopGap = <u64>::sse_decode(deserializer);
        let mut var_validateDomain = <bool>::sse_decode(deserializer);
        return crate::bdk::blockchain::ElectrumConfig {
            url: var_url,
            socks5: var_socks5,
            retry: var_retry,
            timeout: var_timeout,
            stop_gap: var_stopGap,
            validate_domain: var_validateDomain,
        };
    }
}

impl SseDecode for crate::bdk::blockchain::EsploraConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_baseUrl = <String>::sse_decode(deserializer);
        let mut var_proxy = <Option<String>>::sse_decode(deserializer);
        let mut var_concurrency = <Option<u8>>::sse_decode(deserializer);
        let mut var_stopGap = <u64>::sse_decode(deserializer);
        let mut var_timeout = <Option<u64>>::sse_decode(deserializer);
        return crate::bdk::blockchain::EsploraConfig {
            base_url: var_baseUrl,
            proxy: var_proxy,
            concurrency: var_concurrency,
            stop_gap: var_stopGap,
            timeout: var_timeout,
        };
    }
}

impl SseDecode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::bdk::types::ForeignUtxo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_outpoint = <crate::bdk::types::OutPoint>::sse_decode(deserializer);
        let mut var_txout = <crate::bdk::types::TxOutForeign>::sse_decode(deserializer);
        return crate::bdk::types::ForeignUtxo {
            outpoint: var_outpoint,
            txout: var_txout,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::bdk::types::KeychainKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::bdk::types::KeychainKind::Extern,
            1 => crate::bdk::types::KeychainKind::Intern,
            _ => unreachable!("Invalid variant for KeychainKind: {}", inner),
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::bdk::types::ForeignUtxo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::bdk::types::ForeignUtxo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::bdk::wallet::LocalUtxo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::bdk::wallet::LocalUtxo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::bdk::types::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::bdk::types::OutPoint>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::bdk::types::ScriptAmount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::bdk::types::ScriptAmount>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::bdk::types::TransactionDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::bdk::types::TransactionDetails>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::bdk::types::TxBytes> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::bdk::types::TxBytes>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::bdk::types::TxIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::bdk::types::TxIn>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::bdk::types::TxOut> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::bdk::types::TxOut>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::bdk::wallet::LocalUtxo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_outpoint = <crate::bdk::types::OutPoint>::sse_decode(deserializer);
        let mut var_txout = <crate::bdk::types::TxOut>::sse_decode(deserializer);
        let mut var_isSpent = <bool>::sse_decode(deserializer);
        let mut var_keychain = <crate::bdk::types::KeychainKind>::sse_decode(deserializer);
        return crate::bdk::wallet::LocalUtxo {
            outpoint: var_outpoint,
            txout: var_txout,
            is_spent: var_isSpent,
            keychain: var_keychain,
        };
    }
}

impl SseDecode for crate::bdk::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::bdk::types::Network::Testnet,
            1 => crate::bdk::types::Network::Regtest,
            2 => crate::bdk::types::Network::Bitcoin,
            3 => crate::bdk::types::Network::Signet,
            _ => unreachable!("Invalid variant for Network: {}", inner),
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<RustOpaqueMoi<BdkDescriptor>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<RustOpaqueMoi<BdkDescriptor>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::bdk::types::BlockTime> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::bdk::types::BlockTime>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::bdk::types::RbfValue> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::bdk::types::RbfValue>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::bdk::blockchain::RpcSyncParams> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::bdk::blockchain::RpcSyncParams>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::bdk::types::Script> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::bdk::types::Script>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::bdk::wallet::SignOptions> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::bdk::wallet::SignOptions>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u8>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::bdk::blockchain::UserPass> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::bdk::blockchain::UserPass>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<u8>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::bdk::types::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        return crate::bdk::types::OutPoint {
            txid: var_txid,
            vout: var_vout,
        };
    }
}

impl SseDecode for crate::bdk::types::Payload {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_pubkeyHash = <Vec<u8>>::sse_decode(deserializer);
                return crate::bdk::types::Payload::PubkeyHash {
                    pubkey_hash: var_pubkeyHash,
                };
            }
            1 => {
                let mut var_scriptHash = <Vec<u8>>::sse_decode(deserializer);
                return crate::bdk::types::Payload::ScriptHash {
                    script_hash: var_scriptHash,
                };
            }
            2 => {
                let mut var_version = <crate::bdk::types::WitnessVersion>::sse_decode(deserializer);
                let mut var_program = <Vec<u8>>::sse_decode(deserializer);
                return crate::bdk::types::Payload::WitnessProgram {
                    version: var_version,
                    program: var_program,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::bdk::types::RbfValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::bdk::types::RbfValue::RbfDefault;
            }
            1 => {
                let mut var_field0 = <u32>::sse_decode(deserializer);
                return crate::bdk::types::RbfValue::Value(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::bdk::blockchain::RpcConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_authCookie = <Option<String>>::sse_decode(deserializer);
        let mut var_authUserPass =
            <Option<crate::bdk::blockchain::UserPass>>::sse_decode(deserializer);
        let mut var_network = <crate::bdk::types::Network>::sse_decode(deserializer);
        let mut var_walletName = <String>::sse_decode(deserializer);
        let mut var_syncParams =
            <Option<crate::bdk::blockchain::RpcSyncParams>>::sse_decode(deserializer);
        return crate::bdk::blockchain::RpcConfig {
            url: var_url,
            auth_cookie: var_authCookie,
            auth_user_pass: var_authUserPass,
            network: var_network,
            wallet_name: var_walletName,
            sync_params: var_syncParams,
        };
    }
}

impl SseDecode for crate::bdk::blockchain::RpcSyncParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_startScriptCount = <u64>::sse_decode(deserializer);
        let mut var_startTime = <u64>::sse_decode(deserializer);
        let mut var_forceStartTime = <bool>::sse_decode(deserializer);
        let mut var_pollRateSec = <u64>::sse_decode(deserializer);
        return crate::bdk::blockchain::RpcSyncParams {
            start_script_count: var_startScriptCount,
            start_time: var_startTime,
            force_start_time: var_forceStartTime,
            poll_rate_sec: var_pollRateSec,
        };
    }
}

impl SseDecode for crate::bdk::types::Script {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_internal = <Vec<u8>>::sse_decode(deserializer);
        return crate::bdk::types::Script {
            internal: var_internal,
        };
    }
}

impl SseDecode for crate::bdk::types::ScriptAmount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_script = <crate::bdk::types::Script>::sse_decode(deserializer);
        let mut var_amount = <u64>::sse_decode(deserializer);
        return crate::bdk::types::ScriptAmount {
            script: var_script,
            amount: var_amount,
        };
    }
}

impl SseDecode for crate::types::Secp256k1FromSeedReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_seed = <Vec<u8>>::sse_decode(deserializer);
        return crate::types::Secp256k1FromSeedReq { seed: var_seed };
    }
}

impl SseDecode for crate::secp256k1::Secp256k1IdentityExport {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_privateKeyHash = <Vec<u8>>::sse_decode(deserializer);
        let mut var_derEncodedPublicKey = <Vec<u8>>::sse_decode(deserializer);
        return crate::secp256k1::Secp256k1IdentityExport {
            private_key_hash: var_privateKeyHash,
            der_encoded_public_key: var_derEncodedPublicKey,
        };
    }
}

impl SseDecode for crate::types::Secp256k1RecoverReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_messagePreHashed = <Vec<u8>>::sse_decode(deserializer);
        let mut var_signatureBytes = <Vec<u8>>::sse_decode(deserializer);
        let mut var_chainId = <Option<u8>>::sse_decode(deserializer);
        return crate::types::Secp256k1RecoverReq {
            message_pre_hashed: var_messagePreHashed,
            signature_bytes: var_signatureBytes,
            chain_id: var_chainId,
        };
    }
}

impl SseDecode for crate::types::Secp256k1ShareSecretReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_seed = <Vec<u8>>::sse_decode(deserializer);
        let mut var_publicKeyRawBytes = <Vec<u8>>::sse_decode(deserializer);
        return crate::types::Secp256k1ShareSecretReq {
            seed: var_seed,
            public_key_raw_bytes: var_publicKeyRawBytes,
        };
    }
}

impl SseDecode for crate::types::Secp256k1SignWithRngReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_msg = <Vec<u8>>::sse_decode(deserializer);
        let mut var_privateBytes = <Vec<u8>>::sse_decode(deserializer);
        return crate::types::Secp256k1SignWithRngReq {
            msg: var_msg,
            private_bytes: var_privateBytes,
        };
    }
}

impl SseDecode for crate::types::Secp256k1SignWithSeedReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_msg = <Vec<u8>>::sse_decode(deserializer);
        let mut var_seed = <Vec<u8>>::sse_decode(deserializer);
        return crate::types::Secp256k1SignWithSeedReq {
            msg: var_msg,
            seed: var_seed,
        };
    }
}

impl SseDecode for crate::types::Secp256k1VerifyReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_messageHash = <Vec<u8>>::sse_decode(deserializer);
        let mut var_signatureBytes = <Vec<u8>>::sse_decode(deserializer);
        let mut var_publicKeyBytes = <Vec<u8>>::sse_decode(deserializer);
        return crate::types::Secp256k1VerifyReq {
            message_hash: var_messageHash,
            signature_bytes: var_signatureBytes,
            public_key_bytes: var_publicKeyBytes,
        };
    }
}

impl SseDecode for crate::bdk::wallet::SignOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_trustWitnessUtxo = <bool>::sse_decode(deserializer);
        let mut var_assumeHeight = <Option<u32>>::sse_decode(deserializer);
        let mut var_allowAllSighashes = <bool>::sse_decode(deserializer);
        let mut var_removePartialSigs = <bool>::sse_decode(deserializer);
        let mut var_tryFinalize = <bool>::sse_decode(deserializer);
        let mut var_finalizeMineOnly = <bool>::sse_decode(deserializer);
        let mut var_signWithTapInternalKey = <bool>::sse_decode(deserializer);
        let mut var_allowGrinding = <bool>::sse_decode(deserializer);
        return crate::bdk::wallet::SignOptions {
            trust_witness_utxo: var_trustWitnessUtxo,
            assume_height: var_assumeHeight,
            allow_all_sighashes: var_allowAllSighashes,
            remove_partial_sigs: var_removePartialSigs,
            try_finalize: var_tryFinalize,
            finalize_mine_only: var_finalizeMineOnly,
            sign_with_tap_internal_key: var_signWithTapInternalKey,
            allow_grinding: var_allowGrinding,
        };
    }
}

impl SseDecode for crate::types::SignatureFFI {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_publicKey = <Option<Vec<u8>>>::sse_decode(deserializer);
        let mut var_signature = <Option<Vec<u8>>>::sse_decode(deserializer);
        return crate::types::SignatureFFI {
            public_key: var_publicKey,
            signature: var_signature,
        };
    }
}

impl SseDecode for crate::bdk::wallet::SledDbConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_path = <String>::sse_decode(deserializer);
        let mut var_treeName = <String>::sse_decode(deserializer);
        return crate::bdk::wallet::SledDbConfiguration {
            path: var_path,
            tree_name: var_treeName,
        };
    }
}

impl SseDecode for crate::bdk::wallet::SqliteDbConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_path = <String>::sse_decode(deserializer);
        return crate::bdk::wallet::SqliteDbConfiguration { path: var_path };
    }
}

impl SseDecode for crate::bdk::types::TransactionDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_serializedTx = <Option<String>>::sse_decode(deserializer);
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_received = <u64>::sse_decode(deserializer);
        let mut var_sent = <u64>::sse_decode(deserializer);
        let mut var_fee = <Option<u64>>::sse_decode(deserializer);
        let mut var_confirmationTime =
            <Option<crate::bdk::types::BlockTime>>::sse_decode(deserializer);
        return crate::bdk::types::TransactionDetails {
            serialized_tx: var_serializedTx,
            txid: var_txid,
            received: var_received,
            sent: var_sent,
            fee: var_fee,
            confirmation_time: var_confirmationTime,
        };
    }
}

impl SseDecode for crate::bdk::types::TxBytes {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txId = <String>::sse_decode(deserializer);
        let mut var_bytes = <Vec<u8>>::sse_decode(deserializer);
        return crate::bdk::types::TxBytes {
            tx_id: var_txId,
            bytes: var_bytes,
        };
    }
}

impl SseDecode for crate::bdk::types::TxIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_previousOutput = <crate::bdk::types::OutPoint>::sse_decode(deserializer);
        let mut var_scriptSig = <crate::bdk::types::Script>::sse_decode(deserializer);
        let mut var_sequence = <u32>::sse_decode(deserializer);
        let mut var_witness = <Vec<String>>::sse_decode(deserializer);
        return crate::bdk::types::TxIn {
            previous_output: var_previousOutput,
            script_sig: var_scriptSig,
            sequence: var_sequence,
            witness: var_witness,
        };
    }
}

impl SseDecode for crate::bdk::types::TxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <u64>::sse_decode(deserializer);
        let mut var_scriptPubkey = <crate::bdk::types::Script>::sse_decode(deserializer);
        return crate::bdk::types::TxOut {
            value: var_value,
            script_pubkey: var_scriptPubkey,
        };
    }
}

impl SseDecode for crate::bdk::types::TxOutForeign {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <u64>::sse_decode(deserializer);
        let mut var_scriptPubkey = <String>::sse_decode(deserializer);
        return crate::bdk::types::TxOutForeign {
            value: var_value,
            script_pubkey: var_scriptPubkey,
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::bdk::blockchain::UserPass {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_username = <String>::sse_decode(deserializer);
        let mut var_password = <String>::sse_decode(deserializer);
        return crate::bdk::blockchain::UserPass {
            username: var_username,
            password: var_password,
        };
    }
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::bdk::types::WitnessVersion {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::bdk::types::WitnessVersion::V0,
            1 => crate::bdk::types::WitnessVersion::V1,
            2 => crate::bdk::types::WitnessVersion::V2,
            3 => crate::bdk::types::WitnessVersion::V3,
            4 => crate::bdk::types::WitnessVersion::V4,
            5 => crate::bdk::types::WitnessVersion::V5,
            6 => crate::bdk::types::WitnessVersion::V6,
            7 => crate::bdk::types::WitnessVersion::V7,
            8 => crate::bdk::types::WitnessVersion::V8,
            9 => crate::bdk::types::WitnessVersion::V9,
            10 => crate::bdk::types::WitnessVersion::V10,
            11 => crate::bdk::types::WitnessVersion::V11,
            12 => crate::bdk::types::WitnessVersion::V12,
            13 => crate::bdk::types::WitnessVersion::V13,
            14 => crate::bdk::types::WitnessVersion::V14,
            15 => crate::bdk::types::WitnessVersion::V15,
            16 => crate::bdk::types::WitnessVersion::V16,
            _ => unreachable!("Invalid variant for WitnessVersion: {}", inner),
        };
    }
}

impl SseDecode for crate::bdk::types::WordCount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::bdk::types::WordCount::Words12,
            1 => crate::bdk::types::WordCount::Words18,
            2 => crate::bdk::types::WordCount::Words24,
            _ => unreachable!("Invalid variant for WordCount: {}", inner),
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__api_address_from_script_impl(port, ptr, rust_vec_len, data_len),
        2 => wire__crate__api__api_address_network_impl(port, ptr, rust_vec_len, data_len),
        3 => wire__crate__api__api_address_to_script_pubkey_impl(port, ptr, rust_vec_len, data_len),
        4 => wire__crate__api__api_as_public_impl(port, ptr, rust_vec_len, data_len),
        5 => wire__crate__api__api_as_secret_bytes_impl(port, ptr, rust_vec_len, data_len),
        6 => wire__crate__api__api_as_string_impl(port, ptr, rust_vec_len, data_len),
        7 => wire__crate__api__api_as_string_private_impl(port, ptr, rust_vec_len, data_len),
        8 => wire__crate__api__api_bip322_sign_segwit_impl(port, ptr, rust_vec_len, data_len),
        9 => wire__crate__api__api_bip322_sign_taproot_impl(port, ptr, rust_vec_len, data_len),
        10 => wire__crate__api__api_broadcast_impl(port, ptr, rust_vec_len, data_len),
        11 => {
            wire__crate__api__api_bump_fee_tx_builder_finish_impl(port, ptr, rust_vec_len, data_len)
        }
        12 => wire__crate__api__api_cache_address_impl(port, ptr, rust_vec_len, data_len),
        13 => wire__crate__api__api_combine_psbt_impl(port, ptr, rust_vec_len, data_len),
        14 => wire__crate__api__api_create_address_impl(port, ptr, rust_vec_len, data_len),
        15 => wire__crate__api__api_create_blockchain_impl(port, ptr, rust_vec_len, data_len),
        16 => wire__crate__api__api_create_derivation_path_impl(port, ptr, rust_vec_len, data_len),
        17 => wire__crate__api__api_create_derived_descriptor_secret_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        18 => wire__crate__api__api_create_descriptor_impl(port, ptr, rust_vec_len, data_len),
        19 => {
            wire__crate__api__api_create_descriptor_public_impl(port, ptr, rust_vec_len, data_len)
        }
        20 => {
            wire__crate__api__api_create_descriptor_secret_impl(port, ptr, rust_vec_len, data_len)
        }
        21 => wire__crate__api__api_create_script_impl(port, ptr, rust_vec_len, data_len),
        22 => wire__crate__api__api_create_transaction_impl(port, ptr, rust_vec_len, data_len),
        23 => wire__crate__api__api_create_wallet_impl(port, ptr, rust_vec_len, data_len),
        24 => wire__crate__api__api_derive_address_at_impl(port, ptr, rust_vec_len, data_len),
        25 => {
            wire__crate__api__api_derive_descriptor_secret_impl(port, ptr, rust_vec_len, data_len)
        }
        26 => wire__crate__api__api_descriptor_public_from_string_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        27 => wire__crate__api__api_descriptor_secret_from_string_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        28 => wire__crate__api__api_estimate_fee_impl(port, ptr, rust_vec_len, data_len),
        29 => {
            wire__crate__api__api_extend_descriptor_secret_impl(port, ptr, rust_vec_len, data_len)
        }
        30 => wire__crate__api__api_extract_tx_impl(port, ptr, rust_vec_len, data_len),
        31 => {
            wire__crate__api__api_generate_seed_from_entropy_impl(port, ptr, rust_vec_len, data_len)
        }
        32 => {
            wire__crate__api__api_generate_seed_from_string_impl(port, ptr, rust_vec_len, data_len)
        }
        33 => wire__crate__api__api_generate_seed_from_word_count_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        34 => wire__crate__api__api_get_address_impl(port, ptr, rust_vec_len, data_len),
        35 => wire__crate__api__api_get_address_type_impl(port, ptr, rust_vec_len, data_len),
        36 => wire__crate__api__api_get_balance_impl(port, ptr, rust_vec_len, data_len),
        37 => wire__crate__api__api_get_blockchain_hash_impl(port, ptr, rust_vec_len, data_len),
        38 => wire__crate__api__api_get_height_impl(port, ptr, rust_vec_len, data_len),
        39 => wire__crate__api__api_get_inputs_impl(port, ptr, rust_vec_len, data_len),
        40 => wire__crate__api__api_get_internal_address_impl(port, ptr, rust_vec_len, data_len),
        41 => {
            wire__crate__api__api_get_pub_from_secret_bytes_impl(port, ptr, rust_vec_len, data_len)
        }
        42 => wire__crate__api__api_get_transactions_impl(port, ptr, rust_vec_len, data_len),
        43 => wire__crate__api__api_get_tx_impl(port, ptr, rust_vec_len, data_len),
        44 => wire__crate__api__api_import_single_wif_impl(port, ptr, rust_vec_len, data_len),
        45 => wire__crate__api__api_input_impl(port, ptr, rust_vec_len, data_len),
        46 => wire__crate__api__api_is_coin_base_impl(port, ptr, rust_vec_len, data_len),
        47 => wire__crate__api__api_is_explicitly_rbf_impl(port, ptr, rust_vec_len, data_len),
        48 => wire__crate__api__api_is_lock_time_enabled_impl(port, ptr, rust_vec_len, data_len),
        49 => wire__crate__api__api_json_serialize_impl(port, ptr, rust_vec_len, data_len),
        50 => wire__crate__api__api_list_unspent_impl(port, ptr, rust_vec_len, data_len),
        51 => wire__crate__api__api_list_unspent_outputs_impl(port, ptr, rust_vec_len, data_len),
        52 => wire__crate__api__api_lock_time_impl(port, ptr, rust_vec_len, data_len),
        53 => wire__crate__api__api_master_finterprint_impl(port, ptr, rust_vec_len, data_len),
        54 => wire__crate__api__api_new_bip44_descriptor_impl(port, ptr, rust_vec_len, data_len),
        55 => wire__crate__api__api_new_bip44_public_impl(port, ptr, rust_vec_len, data_len),
        56 => wire__crate__api__api_new_bip44_tr_descriptor_impl(port, ptr, rust_vec_len, data_len),
        57 => wire__crate__api__api_new_bip44_tr_public_impl(port, ptr, rust_vec_len, data_len),
        58 => wire__crate__api__api_new_bip49_descriptor_impl(port, ptr, rust_vec_len, data_len),
        59 => wire__crate__api__api_new_bip49_public_impl(port, ptr, rust_vec_len, data_len),
        60 => wire__crate__api__api_new_bip84_descriptor_impl(port, ptr, rust_vec_len, data_len),
        61 => wire__crate__api__api_new_bip84_public_impl(port, ptr, rust_vec_len, data_len),
        62 => wire__crate__api__api_new_bip86_descriptor_impl(port, ptr, rust_vec_len, data_len),
        63 => wire__crate__api__api_new_bip86_public_impl(port, ptr, rust_vec_len, data_len),
        64 => wire__crate__api__api_output_impl(port, ptr, rust_vec_len, data_len),
        65 => wire__crate__api__api_payload_impl(port, ptr, rust_vec_len, data_len),
        66 => wire__crate__api__api_psbt_fee_amount_impl(port, ptr, rust_vec_len, data_len),
        67 => wire__crate__api__api_psbt_fee_rate_impl(port, ptr, rust_vec_len, data_len),
        68 => wire__crate__api__api_psbt_txid_impl(port, ptr, rust_vec_len, data_len),
        69 => wire__crate__api__api_serialize_psbt_impl(port, ptr, rust_vec_len, data_len),
        70 => wire__crate__api__api_serialize_tx_impl(port, ptr, rust_vec_len, data_len),
        71 => wire__crate__api__api_sign_impl(port, ptr, rust_vec_len, data_len),
        72 => wire__crate__api__api_size_impl(port, ptr, rust_vec_len, data_len),
        73 => wire__crate__api__api_to_public_string_impl(port, ptr, rust_vec_len, data_len),
        74 => wire__crate__api__api_tx_builder_finish_impl(port, ptr, rust_vec_len, data_len),
        75 => wire__crate__api__api_tx_cal_fee_finish_impl(port, ptr, rust_vec_len, data_len),
        76 => wire__crate__api__api_tx_txid_impl(port, ptr, rust_vec_len, data_len),
        77 => wire__crate__api__api_version_impl(port, ptr, rust_vec_len, data_len),
        78 => wire__crate__api__api_vsize_impl(port, ptr, rust_vec_len, data_len),
        79 => wire__crate__api__api_wallet_network_impl(port, ptr, rust_vec_len, data_len),
        80 => wire__crate__api__api_weight_impl(port, ptr, rust_vec_len, data_len),
        81 => wire__crate__api__hex_bytes_to_wif_impl(port, ptr, rust_vec_len, data_len),
        82 => wire__crate__api__secp256k1_from_seed_impl(port, ptr, rust_vec_len, data_len),
        83 => wire__crate__api__secp256k1_get_shared_secret_impl(port, ptr, rust_vec_len, data_len),
        84 => wire__crate__api__secp256k1_recover_impl(port, ptr, rust_vec_len, data_len),
        85 => wire__crate__api__secp256k1_sign_impl(port, ptr, rust_vec_len, data_len),
        86 => wire__crate__api__secp256k1_sign_recoverable_impl(port, ptr, rust_vec_len, data_len),
        87 => wire__crate__api__secp256k1_sign_with_rng_impl(port, ptr, rust_vec_len, data_len),
        88 => wire__crate__api__secp256k1_verify_impl(port, ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::AddressIndex {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::bdk::types::AddressIndex::NewIndex => [0.into_dart()].into_dart(),
            crate::bdk::types::AddressIndex::LastUnused => [1.into_dart()].into_dart(),
            crate::bdk::types::AddressIndex::Peek { index } => {
                [2.into_dart(), index.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::types::AddressIndex::Reset { index } => {
                [3.into_dart(), index.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::AddressIndex
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::AddressIndex>
    for crate::bdk::types::AddressIndex
{
    fn into_into_dart(self) -> crate::bdk::types::AddressIndex {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::AddressInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.index.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::AddressInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::AddressInfo>
    for crate::bdk::types::AddressInfo
{
    fn into_into_dart(self) -> crate::bdk::types::AddressInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::Api {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::Api {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::Api> for crate::api::Api {
    fn into_into_dart(self) -> crate::api::Api {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::Balance {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.immature.into_into_dart().into_dart(),
            self.trusted_pending.into_into_dart().into_dart(),
            self.untrusted_pending.into_into_dart().into_dart(),
            self.confirmed.into_into_dart().into_dart(),
            self.spendable.into_into_dart().into_dart(),
            self.total.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::Balance {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::Balance> for crate::bdk::types::Balance {
    fn into_into_dart(self) -> crate::bdk::types::Balance {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::BdkTxBuilderResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.into_into_dart().into_dart(),
            self.1.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::BdkTxBuilderResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::BdkTxBuilderResult>
    for crate::bdk::types::BdkTxBuilderResult
{
    fn into_into_dart(self) -> crate::bdk::types::BdkTxBuilderResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::BlockTime {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.height.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::BlockTime {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::BlockTime>
    for crate::bdk::types::BlockTime
{
    fn into_into_dart(self) -> crate::bdk::types::BlockTime {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::blockchain::BlockchainConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::bdk::blockchain::BlockchainConfig::Electrum { config } => {
                [0.into_dart(), config.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::blockchain::BlockchainConfig::Esplora { config } => {
                [1.into_dart(), config.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::blockchain::BlockchainConfig::Rpc { config } => {
                [2.into_dart(), config.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::blockchain::BlockchainConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::blockchain::BlockchainConfig>
    for crate::bdk::blockchain::BlockchainConfig
{
    fn into_into_dart(self) -> crate::bdk::blockchain::BlockchainConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::ChangeSpendPolicy {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::ChangeAllowed => 0.into_dart(),
            Self::OnlyChange => 1.into_dart(),
            Self::ChangeForbidden => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::ChangeSpendPolicy
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::ChangeSpendPolicy>
    for crate::bdk::types::ChangeSpendPolicy
{
    fn into_into_dart(self) -> crate::bdk::types::ChangeSpendPolicy {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::wallet::DatabaseConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::bdk::wallet::DatabaseConfig::Memory => [0.into_dart()].into_dart(),
            crate::bdk::wallet::DatabaseConfig::Sqlite { config } => {
                [1.into_dart(), config.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::wallet::DatabaseConfig::Sled { config } => {
                [2.into_dart(), config.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::wallet::DatabaseConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::wallet::DatabaseConfig>
    for crate::bdk::wallet::DatabaseConfig
{
    fn into_into_dart(self) -> crate::bdk::wallet::DatabaseConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::blockchain::ElectrumConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.url.into_into_dart().into_dart(),
            self.socks5.into_into_dart().into_dart(),
            self.retry.into_into_dart().into_dart(),
            self.timeout.into_into_dart().into_dart(),
            self.stop_gap.into_into_dart().into_dart(),
            self.validate_domain.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::blockchain::ElectrumConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::blockchain::ElectrumConfig>
    for crate::bdk::blockchain::ElectrumConfig
{
    fn into_into_dart(self) -> crate::bdk::blockchain::ElectrumConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::blockchain::EsploraConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.base_url.into_into_dart().into_dart(),
            self.proxy.into_into_dart().into_dart(),
            self.concurrency.into_into_dart().into_dart(),
            self.stop_gap.into_into_dart().into_dart(),
            self.timeout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::blockchain::EsploraConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::blockchain::EsploraConfig>
    for crate::bdk::blockchain::EsploraConfig
{
    fn into_into_dart(self) -> crate::bdk::blockchain::EsploraConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::ForeignUtxo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.outpoint.into_into_dart().into_dart(),
            self.txout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::ForeignUtxo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::ForeignUtxo>
    for crate::bdk::types::ForeignUtxo
{
    fn into_into_dart(self) -> crate::bdk::types::ForeignUtxo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::KeychainKind {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Extern => 0.into_dart(),
            Self::Intern => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::KeychainKind
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::KeychainKind>
    for crate::bdk::types::KeychainKind
{
    fn into_into_dart(self) -> crate::bdk::types::KeychainKind {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::wallet::LocalUtxo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.outpoint.into_into_dart().into_dart(),
            self.txout.into_into_dart().into_dart(),
            self.is_spent.into_into_dart().into_dart(),
            self.keychain.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::wallet::LocalUtxo {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::wallet::LocalUtxo>
    for crate::bdk::wallet::LocalUtxo
{
    fn into_into_dart(self) -> crate::bdk::wallet::LocalUtxo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::Network {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Testnet => 0.into_dart(),
            Self::Regtest => 1.into_dart(),
            Self::Bitcoin => 2.into_dart(),
            Self::Signet => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::Network {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::Network> for crate::bdk::types::Network {
    fn into_into_dart(self) -> crate::bdk::types::Network {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::OutPoint {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.vout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::OutPoint {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::OutPoint>
    for crate::bdk::types::OutPoint
{
    fn into_into_dart(self) -> crate::bdk::types::OutPoint {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::Payload {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::bdk::types::Payload::PubkeyHash { pubkey_hash } => {
                [0.into_dart(), pubkey_hash.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::types::Payload::ScriptHash { script_hash } => {
                [1.into_dart(), script_hash.into_into_dart().into_dart()].into_dart()
            }
            crate::bdk::types::Payload::WitnessProgram { version, program } => [
                2.into_dart(),
                version.into_into_dart().into_dart(),
                program.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::Payload {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::Payload> for crate::bdk::types::Payload {
    fn into_into_dart(self) -> crate::bdk::types::Payload {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::RbfValue {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::bdk::types::RbfValue::RbfDefault => [0.into_dart()].into_dart(),
            crate::bdk::types::RbfValue::Value(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::RbfValue {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::RbfValue>
    for crate::bdk::types::RbfValue
{
    fn into_into_dart(self) -> crate::bdk::types::RbfValue {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::blockchain::RpcConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.url.into_into_dart().into_dart(),
            self.auth_cookie.into_into_dart().into_dart(),
            self.auth_user_pass.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.wallet_name.into_into_dart().into_dart(),
            self.sync_params.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::blockchain::RpcConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::blockchain::RpcConfig>
    for crate::bdk::blockchain::RpcConfig
{
    fn into_into_dart(self) -> crate::bdk::blockchain::RpcConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::blockchain::RpcSyncParams {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.start_script_count.into_into_dart().into_dart(),
            self.start_time.into_into_dart().into_dart(),
            self.force_start_time.into_into_dart().into_dart(),
            self.poll_rate_sec.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::blockchain::RpcSyncParams
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::blockchain::RpcSyncParams>
    for crate::bdk::blockchain::RpcSyncParams
{
    fn into_into_dart(self) -> crate::bdk::blockchain::RpcSyncParams {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::Script {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.internal.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::Script {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::Script> for crate::bdk::types::Script {
    fn into_into_dart(self) -> crate::bdk::types::Script {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::ScriptAmount {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.script.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::ScriptAmount
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::ScriptAmount>
    for crate::bdk::types::ScriptAmount
{
    fn into_into_dart(self) -> crate::bdk::types::ScriptAmount {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::Secp256k1FromSeedReq {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.seed.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::types::Secp256k1FromSeedReq
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::types::Secp256k1FromSeedReq>
    for crate::types::Secp256k1FromSeedReq
{
    fn into_into_dart(self) -> crate::types::Secp256k1FromSeedReq {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::secp256k1::Secp256k1IdentityExport {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.private_key_hash.into_into_dart().into_dart(),
            self.der_encoded_public_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::secp256k1::Secp256k1IdentityExport
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::secp256k1::Secp256k1IdentityExport>
    for crate::secp256k1::Secp256k1IdentityExport
{
    fn into_into_dart(self) -> crate::secp256k1::Secp256k1IdentityExport {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::Secp256k1RecoverReq {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.message_pre_hashed.into_into_dart().into_dart(),
            self.signature_bytes.into_into_dart().into_dart(),
            self.chain_id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::types::Secp256k1RecoverReq
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::types::Secp256k1RecoverReq>
    for crate::types::Secp256k1RecoverReq
{
    fn into_into_dart(self) -> crate::types::Secp256k1RecoverReq {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::Secp256k1ShareSecretReq {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.seed.into_into_dart().into_dart(),
            self.public_key_raw_bytes.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::types::Secp256k1ShareSecretReq
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::types::Secp256k1ShareSecretReq>
    for crate::types::Secp256k1ShareSecretReq
{
    fn into_into_dart(self) -> crate::types::Secp256k1ShareSecretReq {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::Secp256k1SignWithRngReq {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.msg.into_into_dart().into_dart(),
            self.private_bytes.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::types::Secp256k1SignWithRngReq
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::types::Secp256k1SignWithRngReq>
    for crate::types::Secp256k1SignWithRngReq
{
    fn into_into_dart(self) -> crate::types::Secp256k1SignWithRngReq {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::Secp256k1SignWithSeedReq {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.msg.into_into_dart().into_dart(),
            self.seed.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::types::Secp256k1SignWithSeedReq
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::types::Secp256k1SignWithSeedReq>
    for crate::types::Secp256k1SignWithSeedReq
{
    fn into_into_dart(self) -> crate::types::Secp256k1SignWithSeedReq {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::Secp256k1VerifyReq {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.message_hash.into_into_dart().into_dart(),
            self.signature_bytes.into_into_dart().into_dart(),
            self.public_key_bytes.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::types::Secp256k1VerifyReq
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::types::Secp256k1VerifyReq>
    for crate::types::Secp256k1VerifyReq
{
    fn into_into_dart(self) -> crate::types::Secp256k1VerifyReq {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::wallet::SignOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.trust_witness_utxo.into_into_dart().into_dart(),
            self.assume_height.into_into_dart().into_dart(),
            self.allow_all_sighashes.into_into_dart().into_dart(),
            self.remove_partial_sigs.into_into_dart().into_dart(),
            self.try_finalize.into_into_dart().into_dart(),
            self.finalize_mine_only.into_into_dart().into_dart(),
            self.sign_with_tap_internal_key.into_into_dart().into_dart(),
            self.allow_grinding.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::wallet::SignOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::wallet::SignOptions>
    for crate::bdk::wallet::SignOptions
{
    fn into_into_dart(self) -> crate::bdk::wallet::SignOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::SignatureFFI {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.public_key.into_into_dart().into_dart(),
            self.signature.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::types::SignatureFFI {}
impl flutter_rust_bridge::IntoIntoDart<crate::types::SignatureFFI> for crate::types::SignatureFFI {
    fn into_into_dart(self) -> crate::types::SignatureFFI {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::wallet::SledDbConfiguration {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.path.into_into_dart().into_dart(),
            self.tree_name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::wallet::SledDbConfiguration
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::wallet::SledDbConfiguration>
    for crate::bdk::wallet::SledDbConfiguration
{
    fn into_into_dart(self) -> crate::bdk::wallet::SledDbConfiguration {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::wallet::SqliteDbConfiguration {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.path.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::wallet::SqliteDbConfiguration
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::wallet::SqliteDbConfiguration>
    for crate::bdk::wallet::SqliteDbConfiguration
{
    fn into_into_dart(self) -> crate::bdk::wallet::SqliteDbConfiguration {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::TransactionDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.serialized_tx.into_into_dart().into_dart(),
            self.txid.into_into_dart().into_dart(),
            self.received.into_into_dart().into_dart(),
            self.sent.into_into_dart().into_dart(),
            self.fee.into_into_dart().into_dart(),
            self.confirmation_time.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::TransactionDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::TransactionDetails>
    for crate::bdk::types::TransactionDetails
{
    fn into_into_dart(self) -> crate::bdk::types::TransactionDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::TxBytes {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.tx_id.into_into_dart().into_dart(),
            self.bytes.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::TxBytes {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::TxBytes> for crate::bdk::types::TxBytes {
    fn into_into_dart(self) -> crate::bdk::types::TxBytes {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::TxIn {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.previous_output.into_into_dart().into_dart(),
            self.script_sig.into_into_dart().into_dart(),
            self.sequence.into_into_dart().into_dart(),
            self.witness.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::TxIn {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::TxIn> for crate::bdk::types::TxIn {
    fn into_into_dart(self) -> crate::bdk::types::TxIn {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::TxOut {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.value.into_into_dart().into_dart(),
            self.script_pubkey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::TxOut {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::TxOut> for crate::bdk::types::TxOut {
    fn into_into_dart(self) -> crate::bdk::types::TxOut {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::TxOutForeign {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.value.into_into_dart().into_dart(),
            self.script_pubkey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::TxOutForeign
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::TxOutForeign>
    for crate::bdk::types::TxOutForeign
{
    fn into_into_dart(self) -> crate::bdk::types::TxOutForeign {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::blockchain::UserPass {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.username.into_into_dart().into_dart(),
            self.password.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::blockchain::UserPass
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::blockchain::UserPass>
    for crate::bdk::blockchain::UserPass
{
    fn into_into_dart(self) -> crate::bdk::blockchain::UserPass {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::WitnessVersion {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::V0 => 0.into_dart(),
            Self::V1 => 1.into_dart(),
            Self::V2 => 2.into_dart(),
            Self::V3 => 3.into_dart(),
            Self::V4 => 4.into_dart(),
            Self::V5 => 5.into_dart(),
            Self::V6 => 6.into_dart(),
            Self::V7 => 7.into_dart(),
            Self::V8 => 8.into_dart(),
            Self::V9 => 9.into_dart(),
            Self::V10 => 10.into_dart(),
            Self::V11 => 11.into_dart(),
            Self::V12 => 12.into_dart(),
            Self::V13 => 13.into_dart(),
            Self::V14 => 14.into_dart(),
            Self::V15 => 15.into_dart(),
            Self::V16 => 16.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::bdk::types::WitnessVersion
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::WitnessVersion>
    for crate::bdk::types::WitnessVersion
{
    fn into_into_dart(self) -> crate::bdk::types::WitnessVersion {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::bdk::types::WordCount {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Words12 => 0.into_dart(),
            Self::Words18 => 1.into_dart(),
            Self::Words24 => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::bdk::types::WordCount {}
impl flutter_rust_bridge::IntoIntoDart<crate::bdk::types::WordCount>
    for crate::bdk::types::WordCount
{
    fn into_into_dart(self) -> crate::bdk::types::WordCount {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for RustOpaqueMoi<BdkDescriptor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<BlockchainInstance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<WalletInstance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::bdk::types::AddressIndex {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::bdk::types::AddressIndex::NewIndex => {
                <i32>::sse_encode(0, serializer);
            }
            crate::bdk::types::AddressIndex::LastUnused => {
                <i32>::sse_encode(1, serializer);
            }
            crate::bdk::types::AddressIndex::Peek { index } => {
                <i32>::sse_encode(2, serializer);
                <u32>::sse_encode(index, serializer);
            }
            crate::bdk::types::AddressIndex::Reset { index } => {
                <i32>::sse_encode(3, serializer);
                <u32>::sse_encode(index, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::bdk::types::AddressInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.index, serializer);
        <String>::sse_encode(self.address, serializer);
    }
}

impl SseEncode for crate::api::Api {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::bdk::types::Balance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.immature, serializer);
        <u64>::sse_encode(self.trusted_pending, serializer);
        <u64>::sse_encode(self.untrusted_pending, serializer);
        <u64>::sse_encode(self.confirmed, serializer);
        <u64>::sse_encode(self.spendable, serializer);
        <u64>::sse_encode(self.total, serializer);
    }
}

impl SseEncode for crate::bdk::types::BdkTxBuilderResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <crate::bdk::types::TransactionDetails>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::bdk::types::BlockTime {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.height, serializer);
        <u64>::sse_encode(self.timestamp, serializer);
    }
}

impl SseEncode for crate::bdk::blockchain::BlockchainConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::bdk::blockchain::BlockchainConfig::Electrum { config } => {
                <i32>::sse_encode(0, serializer);
                <crate::bdk::blockchain::ElectrumConfig>::sse_encode(config, serializer);
            }
            crate::bdk::blockchain::BlockchainConfig::Esplora { config } => {
                <i32>::sse_encode(1, serializer);
                <crate::bdk::blockchain::EsploraConfig>::sse_encode(config, serializer);
            }
            crate::bdk::blockchain::BlockchainConfig::Rpc { config } => {
                <i32>::sse_encode(2, serializer);
                <crate::bdk::blockchain::RpcConfig>::sse_encode(config, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::bdk::types::ChangeSpendPolicy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::bdk::types::ChangeSpendPolicy::ChangeAllowed => 0,
                crate::bdk::types::ChangeSpendPolicy::OnlyChange => 1,
                crate::bdk::types::ChangeSpendPolicy::ChangeForbidden => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::bdk::wallet::DatabaseConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::bdk::wallet::DatabaseConfig::Memory => {
                <i32>::sse_encode(0, serializer);
            }
            crate::bdk::wallet::DatabaseConfig::Sqlite { config } => {
                <i32>::sse_encode(1, serializer);
                <crate::bdk::wallet::SqliteDbConfiguration>::sse_encode(config, serializer);
            }
            crate::bdk::wallet::DatabaseConfig::Sled { config } => {
                <i32>::sse_encode(2, serializer);
                <crate::bdk::wallet::SledDbConfiguration>::sse_encode(config, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::bdk::blockchain::ElectrumConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.url, serializer);
        <Option<String>>::sse_encode(self.socks5, serializer);
        <u8>::sse_encode(self.retry, serializer);
        <Option<u8>>::sse_encode(self.timeout, serializer);
        <u64>::sse_encode(self.stop_gap, serializer);
        <bool>::sse_encode(self.validate_domain, serializer);
    }
}

impl SseEncode for crate::bdk::blockchain::EsploraConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.base_url, serializer);
        <Option<String>>::sse_encode(self.proxy, serializer);
        <Option<u8>>::sse_encode(self.concurrency, serializer);
        <u64>::sse_encode(self.stop_gap, serializer);
        <Option<u64>>::sse_encode(self.timeout, serializer);
    }
}

impl SseEncode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::bdk::types::ForeignUtxo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::bdk::types::OutPoint>::sse_encode(self.outpoint, serializer);
        <crate::bdk::types::TxOutForeign>::sse_encode(self.txout, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::bdk::types::KeychainKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::bdk::types::KeychainKind::Extern => 0,
                crate::bdk::types::KeychainKind::Intern => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::bdk::types::ForeignUtxo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::bdk::types::ForeignUtxo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::bdk::wallet::LocalUtxo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::bdk::wallet::LocalUtxo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::bdk::types::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::bdk::types::OutPoint>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::bdk::types::ScriptAmount> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::bdk::types::ScriptAmount>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::bdk::types::TransactionDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::bdk::types::TransactionDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::bdk::types::TxBytes> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::bdk::types::TxBytes>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::bdk::types::TxIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::bdk::types::TxIn>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::bdk::types::TxOut> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::bdk::types::TxOut>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::bdk::wallet::LocalUtxo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::bdk::types::OutPoint>::sse_encode(self.outpoint, serializer);
        <crate::bdk::types::TxOut>::sse_encode(self.txout, serializer);
        <bool>::sse_encode(self.is_spent, serializer);
        <crate::bdk::types::KeychainKind>::sse_encode(self.keychain, serializer);
    }
}

impl SseEncode for crate::bdk::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::bdk::types::Network::Testnet => 0,
                crate::bdk::types::Network::Regtest => 1,
                crate::bdk::types::Network::Bitcoin => 2,
                crate::bdk::types::Network::Signet => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<RustOpaqueMoi<BdkDescriptor>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <RustOpaqueMoi<BdkDescriptor>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::bdk::types::BlockTime> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::bdk::types::BlockTime>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::bdk::types::RbfValue> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::bdk::types::RbfValue>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::bdk::blockchain::RpcSyncParams> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::bdk::blockchain::RpcSyncParams>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::bdk::types::Script> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::bdk::types::Script>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::bdk::wallet::SignOptions> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::bdk::wallet::SignOptions>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u8>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::bdk::blockchain::UserPass> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::bdk::blockchain::UserPass>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<u8>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::bdk::types::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
    }
}

impl SseEncode for crate::bdk::types::Payload {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::bdk::types::Payload::PubkeyHash { pubkey_hash } => {
                <i32>::sse_encode(0, serializer);
                <Vec<u8>>::sse_encode(pubkey_hash, serializer);
            }
            crate::bdk::types::Payload::ScriptHash { script_hash } => {
                <i32>::sse_encode(1, serializer);
                <Vec<u8>>::sse_encode(script_hash, serializer);
            }
            crate::bdk::types::Payload::WitnessProgram { version, program } => {
                <i32>::sse_encode(2, serializer);
                <crate::bdk::types::WitnessVersion>::sse_encode(version, serializer);
                <Vec<u8>>::sse_encode(program, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::bdk::types::RbfValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::bdk::types::RbfValue::RbfDefault => {
                <i32>::sse_encode(0, serializer);
            }
            crate::bdk::types::RbfValue::Value(field0) => {
                <i32>::sse_encode(1, serializer);
                <u32>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::bdk::blockchain::RpcConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.url, serializer);
        <Option<String>>::sse_encode(self.auth_cookie, serializer);
        <Option<crate::bdk::blockchain::UserPass>>::sse_encode(self.auth_user_pass, serializer);
        <crate::bdk::types::Network>::sse_encode(self.network, serializer);
        <String>::sse_encode(self.wallet_name, serializer);
        <Option<crate::bdk::blockchain::RpcSyncParams>>::sse_encode(self.sync_params, serializer);
    }
}

impl SseEncode for crate::bdk::blockchain::RpcSyncParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.start_script_count, serializer);
        <u64>::sse_encode(self.start_time, serializer);
        <bool>::sse_encode(self.force_start_time, serializer);
        <u64>::sse_encode(self.poll_rate_sec, serializer);
    }
}

impl SseEncode for crate::bdk::types::Script {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.internal, serializer);
    }
}

impl SseEncode for crate::bdk::types::ScriptAmount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::bdk::types::Script>::sse_encode(self.script, serializer);
        <u64>::sse_encode(self.amount, serializer);
    }
}

impl SseEncode for crate::types::Secp256k1FromSeedReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.seed, serializer);
    }
}

impl SseEncode for crate::secp256k1::Secp256k1IdentityExport {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.private_key_hash, serializer);
        <Vec<u8>>::sse_encode(self.der_encoded_public_key, serializer);
    }
}

impl SseEncode for crate::types::Secp256k1RecoverReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.message_pre_hashed, serializer);
        <Vec<u8>>::sse_encode(self.signature_bytes, serializer);
        <Option<u8>>::sse_encode(self.chain_id, serializer);
    }
}

impl SseEncode for crate::types::Secp256k1ShareSecretReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.seed, serializer);
        <Vec<u8>>::sse_encode(self.public_key_raw_bytes, serializer);
    }
}

impl SseEncode for crate::types::Secp256k1SignWithRngReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.msg, serializer);
        <Vec<u8>>::sse_encode(self.private_bytes, serializer);
    }
}

impl SseEncode for crate::types::Secp256k1SignWithSeedReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.msg, serializer);
        <Vec<u8>>::sse_encode(self.seed, serializer);
    }
}

impl SseEncode for crate::types::Secp256k1VerifyReq {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.message_hash, serializer);
        <Vec<u8>>::sse_encode(self.signature_bytes, serializer);
        <Vec<u8>>::sse_encode(self.public_key_bytes, serializer);
    }
}

impl SseEncode for crate::bdk::wallet::SignOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.trust_witness_utxo, serializer);
        <Option<u32>>::sse_encode(self.assume_height, serializer);
        <bool>::sse_encode(self.allow_all_sighashes, serializer);
        <bool>::sse_encode(self.remove_partial_sigs, serializer);
        <bool>::sse_encode(self.try_finalize, serializer);
        <bool>::sse_encode(self.finalize_mine_only, serializer);
        <bool>::sse_encode(self.sign_with_tap_internal_key, serializer);
        <bool>::sse_encode(self.allow_grinding, serializer);
    }
}

impl SseEncode for crate::types::SignatureFFI {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<Vec<u8>>>::sse_encode(self.public_key, serializer);
        <Option<Vec<u8>>>::sse_encode(self.signature, serializer);
    }
}

impl SseEncode for crate::bdk::wallet::SledDbConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.path, serializer);
        <String>::sse_encode(self.tree_name, serializer);
    }
}

impl SseEncode for crate::bdk::wallet::SqliteDbConfiguration {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.path, serializer);
    }
}

impl SseEncode for crate::bdk::types::TransactionDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.serialized_tx, serializer);
        <String>::sse_encode(self.txid, serializer);
        <u64>::sse_encode(self.received, serializer);
        <u64>::sse_encode(self.sent, serializer);
        <Option<u64>>::sse_encode(self.fee, serializer);
        <Option<crate::bdk::types::BlockTime>>::sse_encode(self.confirmation_time, serializer);
    }
}

impl SseEncode for crate::bdk::types::TxBytes {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.tx_id, serializer);
        <Vec<u8>>::sse_encode(self.bytes, serializer);
    }
}

impl SseEncode for crate::bdk::types::TxIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::bdk::types::OutPoint>::sse_encode(self.previous_output, serializer);
        <crate::bdk::types::Script>::sse_encode(self.script_sig, serializer);
        <u32>::sse_encode(self.sequence, serializer);
        <Vec<String>>::sse_encode(self.witness, serializer);
    }
}

impl SseEncode for crate::bdk::types::TxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.value, serializer);
        <crate::bdk::types::Script>::sse_encode(self.script_pubkey, serializer);
    }
}

impl SseEncode for crate::bdk::types::TxOutForeign {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.value, serializer);
        <String>::sse_encode(self.script_pubkey, serializer);
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::bdk::blockchain::UserPass {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.username, serializer);
        <String>::sse_encode(self.password, serializer);
    }
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::bdk::types::WitnessVersion {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::bdk::types::WitnessVersion::V0 => 0,
                crate::bdk::types::WitnessVersion::V1 => 1,
                crate::bdk::types::WitnessVersion::V2 => 2,
                crate::bdk::types::WitnessVersion::V3 => 3,
                crate::bdk::types::WitnessVersion::V4 => 4,
                crate::bdk::types::WitnessVersion::V5 => 5,
                crate::bdk::types::WitnessVersion::V6 => 6,
                crate::bdk::types::WitnessVersion::V7 => 7,
                crate::bdk::types::WitnessVersion::V8 => 8,
                crate::bdk::types::WitnessVersion::V9 => 9,
                crate::bdk::types::WitnessVersion::V10 => 10,
                crate::bdk::types::WitnessVersion::V11 => 11,
                crate::bdk::types::WitnessVersion::V12 => 12,
                crate::bdk::types::WitnessVersion::V13 => 13,
                crate::bdk::types::WitnessVersion::V14 => 14,
                crate::bdk::types::WitnessVersion::V15 => 15,
                crate::bdk::types::WitnessVersion::V16 => 16,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::bdk::types::WordCount {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::bdk::types::WordCount::Words12 => 0,
                crate::bdk::types::WordCount::Words18 => 1,
                crate::bdk::types::WordCount::Words24 => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.5.0.

    // Section: imports

    use super::*;
    use crate::api::*;
    use crate::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_dart_ffi_rust_arc_increment_strong_count_RustOpaque_BdkDescriptor(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<BdkDescriptor>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_dart_ffi_rust_arc_decrement_strong_count_RustOpaque_BdkDescriptor(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<BdkDescriptor>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_dart_ffi_rust_arc_increment_strong_count_RustOpaque_BlockchainInstance(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<BlockchainInstance>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_dart_ffi_rust_arc_decrement_strong_count_RustOpaque_BlockchainInstance(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<BlockchainInstance>::decrement_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_dart_ffi_rust_arc_increment_strong_count_RustOpaque_WalletInstance(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<WalletInstance>::increment_strong_count(ptr as _);
    }

    #[no_mangle]
    pub extern "C" fn frbgen_bdk_dart_ffi_rust_arc_decrement_strong_count_RustOpaque_WalletInstance(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<WalletInstance>::decrement_strong_count(ptr as _);
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.5.0.

    // Section: imports

    use super::*;
    use crate::api::*;
    use crate::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_BdkDescriptor(ptr: *const std::ffi::c_void) {
        MoiArc::<BdkDescriptor>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_BdkDescriptor(ptr: *const std::ffi::c_void) {
        MoiArc::<BdkDescriptor>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_BlockchainInstance(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<BlockchainInstance>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_BlockchainInstance(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<BlockchainInstance>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_WalletInstance(ptr: *const std::ffi::c_void) {
        MoiArc::<WalletInstance>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_WalletInstance(ptr: *const std::ffi::c_void) {
        MoiArc::<WalletInstance>::decrement_strong_count(ptr as _);
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;
